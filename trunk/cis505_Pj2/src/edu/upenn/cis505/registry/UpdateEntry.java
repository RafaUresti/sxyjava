package edu.upenn.cis505.registry;

/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2009 The University of Pennylvania
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright 
// notice and this paragraph and the following two paragraphs appear in
// all copies. 
//
// IN NO EVENT SHALL THE UNIVERSITY OF PENNSYLVANIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF PENNSYLVANIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. 
//
// THE UNIVERSITY OF PENNSYLVANIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF PENNSYLVANIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
//////////////////////////////////////////////////////////////////////////////
//
// Author: Rafi Rubin
//
//////////////////////////////////////////////////////////////////////////////

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.net.Socket;
import java.net.UnknownHostException;
import java.net.InetSocketAddress;

public class UpdateEntry implements Serializable, Comparable<UpdateEntry> {

	/**
	 * 
	 */
	private static final long serialVersionUID = -8345303123529810504L;

	public final static int ADD_HOST = 0;
	public final static int REMOVE_HOST = 1;

	public static boolean DEBUG = false;

	static {
		if (System.getProperty("DEBUG:SKIP_CHECK") != null)
			DEBUG = true;
	}

	public final static String[] ACTION_STRINGS = { "Add", "Remove" };

	public int action = -1;
	
	public String host = "";
	public int pop_port = 0;
	public int smtp_port = 0;
	public String group = "";
	public int group_port = 0;

	public UpdateEntry(int act, String host, int pop_port, int smtp_port,
			String group, int group_port) {
		this.action = act;
		this.host = host;
		this.pop_port = pop_port;
		this.smtp_port = smtp_port;
		this.group = group;
		this.group_port = group_port;
	}

	public UpdateEntry(int act, ObjectInputStream in)
			throws java.io.IOException {
		action = act;
		host = in.readUTF();
		pop_port = in.readInt();
		smtp_port = in.readInt();
		group = in.readUTF();
		group_port = in.readInt();
	}

	public String toString() {
		return " " + ACTION_STRINGS[action] + " " + group + "@" + host + ":"
				+ pop_port + "," + smtp_port + "," + group_port;
	}

	/**
	 * this method opens a connection to each port to verify they are reachable
	 * 
	 * It's intended as a weak test for cases where one has doubts about
	 * firewall settings
	 * 
	 * @return
	 */
	public boolean check() {
		if (DEBUG)
			return true;

		try {
			Socket sock = new Socket();
			sock.connect(new InetSocketAddress(host, pop_port), 1000);
			if (!sock.isConnected())
				return false;
			sock.close();

			sock = new Socket();
			sock.connect(new InetSocketAddress(host, smtp_port), 1000);
			if (!sock.isConnected())
				return false;
			sock.close();

			sock = new Socket();
			sock.connect(new InetSocketAddress(host, group_port), 1000);
			if (!sock.isConnected())
				return false;
			sock.close();
			return true;
		} catch (java.net.SocketTimeoutException ste) {
			System.out.println("connection failed: SocketTimeoutException");
		} catch (UnknownHostException e) {
			System.out.println("connection failed: UnknownHostException");
		} catch (IOException e) {
			System.out.println("connection failed: IOException");
		}
		return false;
	}

	public int compareTo(UpdateEntry other) {
		if (this == other)
			return 0;
		if (0 != this.host.compareTo(other.host))
			return this.host.compareTo(other.host);
		if (0 != this.group.compareTo(other.group))
			return this.group.compareTo(other.group);
		if (this.pop_port != other.pop_port)
			return (pop_port > other.pop_port) ? 1 : -1;
		if (this.group_port != other.group_port)
			return (group_port > other.group_port) ? 1 : -1;
		if (this.smtp_port != other.smtp_port)
			return (smtp_port > other.smtp_port) ? 1 : -1;
		else
			return 0;
	}

	/**
	 * Note HashSet only calls equals in the even of hashCode collisions
	 * therefore it is necessary to implement both
	 * 
	 * @see java.lang.Object#hashCode() This method was generated by Eclipse
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((group == null) ? 0 : group.hashCode());
		result = prime * result + group_port;
		result = prime * result + ((host == null) ? 0 : host.hashCode());
		result = prime * result + pop_port;
		result = prime * result + smtp_port;
		return result;
	}

	/**
	 * Note HashSet only calls equals in the even of hashCode collisions
	 * therefore it is necessary to implement both
	 * 
	 * @see java.lang.Object#equals(java.lang.Object) This method was generated
	 *      by Eclipse
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof UpdateEntry))
			return false;
		final UpdateEntry other = (UpdateEntry) obj;
		if (group == null) {
			if (other.group != null)
				return false;
		} else if (!group.equals(other.group))
			return false;
		if (group_port != other.group_port)
			return false;
		if (host == null) {
			if (other.host != null)
				return false;
		} else if (!host.equals(other.host))
			return false;
		if (pop_port != other.pop_port)
			return false;
		if (smtp_port != other.smtp_port)
			return false;
		return true;
	}
}
